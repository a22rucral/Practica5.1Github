{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pr\u00e1ctica 5.1 Github","text":""},{"location":"#ejercicios-de-git-y-github","title":"Ejercicios de Git y Github.","text":""},{"location":"#configuracion-repositorio","title":"Configuraci\u00f3n Repositorio","text":"<p>Creamos un repositorio con nombre DEAW. </p> <p></p> <p>Lo clonamos en nuestro repositorio local.</p> <p></p>"},{"location":"#manejo-repositorio","title":"Manejo Repositorio","text":"<p>Crearemos un readme.md, que nos servir\u00e1 para tener una descripci\u00f3n del proyecto / documentaci\u00f3n. </p> <p></p> <p>Tras esto lo a\u00f1adiremos todo a la preparaci\u00f3n y haremos un commit con el siguiente comando. </p> <p></p> <p>A continuaci\u00f3n, con todo preparado, ejecutaremos el siguiente comando para la subida de archivos al repositorio en la nube. </p> <p></p> <p>Ahora crearemos el archivo y la carpeta que no queremos que se suba a github. </p> <p></p> <p>Para que no se suba, existe un archivo, .gitignore, que lo que hace es decirle a git que tipo de archivos o directorios deben ser ignorados y no incluirlos al commit. Con la siguiente manera le decimos que ni privado.txt ni el directorio privada se subir\u00e1n al repositorio. </p> <p></p> <p>Crearemos un tag con el siguiente comando. Esto nos ser\u00e1 de utilidad para marcar un commit de un repositorio para se\u00f1alizar las versiones y ver el progreso. </p> <p></p>"},{"location":"#manejo-social-github","title":"Manejo Social Github.","text":"<p>Edici\u00f3n de perfil, nos pondremos una foto de perfil. </p> <p></p> <p>Ajustaremos la configuraci\u00f3n de seguridad para que sea de autenticaci\u00f3n en dos pasos. </p> <p></p> <p>Tambi\u00e9n podremos seguir a nuestros compa\u00f1eros de trabajo o referentes y darle estrellas a sus repositorios. </p> <p></p> <p></p>"},{"location":"#manejo-git","title":"Manejo Git.","text":"<p>Estos dos usuarios seguidos previamente los pondremos en el readme.md en formato de tabla con un enlace a su github. </p> <p></p> <p>Crearemos la rama V0.2.  Esto nos permitir\u00e1 gestionar y organizar el desarrollo de nuestro trabajo. </p> <p></p> <p>Editaremos el archivo y le haremos un push desde la rama. Tras esto haremos un git merge para fusionar la rama con la rama principal y unificar el trabajo. </p> <p></p> <p></p> <p>En este caso hemos hecho cambios en el mismo archivo a la vez en distintas ramas de forma que cuando la intentas unificar dar\u00e1 error de conflicto, como en la siguiente captura. </p> <p></p> <p>Ejecutaremos los siguientes comandos para listar las ramas unidas a main y las que no.</p> <p></p> <p>Al irnos de nuevo al archivo nos saldr\u00e1 de la siguiente manera indicandonos el conflicto entre ramas. Simplemente lo editaremos y arreglaremos el conflicto. </p> <p></p> <p>Crearemos un tag que se llama igual que la rama v0.2, y la subiremos, pero con una aclaraci\u00f3n, ya que le tienes que indicar si te refieres a la rama o al tag. Se lo indicaremos de la siguiente manera como viene en el comando. </p> <pre><code>git push origin refs/tags/v0.2  // Para indicarle tag.\ngit push origin refs/heads/v0.2 // Para indicarle rama.\n</code></pre> <p></p> <p>Borraremos la rama v0.2 indicandole que es la rama como anteriormente hemos explicado.</p> <p></p> <p>Ejecutaremos el git log para mostrar el historial de los commits. </p> <p>--decorate : Ayuda a identificar en que rama o tag se encuentra cada commit.  --graph: Muestra una representaci\u00f3n gr\u00e1fica del historial de commits. Incluye l\u00edneas y ramas para visualizar como est\u00e1n conectados los commits.  --oneline: Muestra cada commit en una sola l\u00ednea.  --all: Muestra el historial de todas las ramas, no solo de en la que se encuentra. </p>"},{"location":"#ejercicios-de-git-y-github-ii","title":"Ejercicios de Git y Github II.","text":""},{"location":"#ejercicios-de-creacion-y-actualizacion-de-repositorios","title":"Ejercicios de creaci\u00f3n y actualizaci\u00f3n de repositorios.","text":"<ol> <li>Configurar Git definiendo variables de perfil y activando el coloreado de salida. </li> </ol> <ol> <li>Crear un nuevo repositorio cuyo nombre \"Libro\" y mostrar contenido. </li> </ol> <ol> <li>Comprobaremos el estado del repositorio, posteriormente crearemos el fichero indice y le a\u00f1adiremos contenido  y de nuevo revisaremos el estado del repositorio. Tras esto a\u00f1adiremosel fichero a la zona de intercambio temporal y volveremos a comprobar el estado del repositorio. </li> </ol> <ol> <li>Realiza un commit de los \u00faltimos cambios con un mensaje y ver estado del repostorio. </li> </ol> <ol> <li>Cambiar el ficher indice, mostrar los cambios respecto a la \u00faltima versi\u00f3n guardada en el repositorio. </li> </ol> <ol> <li>Mostrar los cambios de la \u00faltima versi\u00f3n, cambiar el mensaje del \u00faltimo commit y volver a mostrar los \u00faltimos cambios del repositorio. </li> </ol>"},{"location":"#comandos-utilizados","title":"Comandos utilizados.","text":"<ul> <li>git config --global (user.name/user.email/ color.ui.auto) : Configura tu nombre, correo y activa el coloreado de Git. </li> <li>git init : Inicializa un repositorio de Git. </li> <li>git status : Muestra el estado del repositorio. </li> <li>git add .: a\u00f1ade todo lo que est\u00e9 por a\u00f1adir al \u00e1rea del staging. </li> <li>git commit : confirma los cambios con un mensaje y verifica que no haya cambios pendientes. </li> <li>git diff : Muestra las diferencias con la \u00faltima versi\u00f3n confirmada. </li> <li>git log --oneline: Muestra los \u00faltimos commits y verfica el historial. </li> </ul>"},{"location":"#ejercicios-de-manejo-del-historial-de-cambios","title":"Ejercicios de manejo del historial de cambios.","text":"<ol> <li>Creamos carpeta de cap\u00edtulos, a\u00f1adimos un fichero con contenido para luego a\u00f1adir los cambios a la zona de intercambio temporal, haremos un commit y luego mostraremos el historial de cambios del repositorio. </li> </ol> <ol> <li>Creamos el fichero, a\u00f1adimos los cambios, hacemos un commit con mensaje y mostramos las diferencias entre la \u00faltima versi\u00f3n y dos versiones anteriores. </li> </ol> <ol> <li>Creamos un fichero, a\u00f1adimos los cambios con un mensaje y mostramos la diferencia entre la primera y ultima version del repositorio.  </li> </ol> <ol> <li>Modificar el fichero, a\u00f1adir los cambios a la zona temporal y hacer un commit con un mensaje, tras esto, mostrar qui\u00e9n ha hecho los cambios. </li> </ol>"},{"location":"#comandos-utilizados_1","title":"Comandos utilizados.","text":"<ul> <li>git diff HEAD~2 Muestra las diferencias entre la \u00faltima versi\u00f3n y dos versiones anteriores. Se puede utilizar tambien el n\u00famero de ID del commit. </li> <li>git blamme  &lt;archivo&gt; muestra quien ha editado el archivo. </li> </ul>"},{"location":"#ejercicios-de-deshacer-cambios","title":"Ejercicios de deshacer cambios.","text":"<ol> <li>Eliminar la ultima l\u00ednea del fichero y guardarlo, comprobar el estado del repositorio, deshacer los cambios realizados en el fichero para volver a la versi\u00f3n anterior del fichero y volver a comprobar el estado del repositorio. </li> </ol> <ol> <li>Eliminar la ultima l\u00ednea del fichero, a\u00f1adirlo a la zona de intercambio, comprobaremos el estado del repositorio, despu\u00e9s, quitaremos los cambios de la zona de intercambio temporal pero mantenerlos en el directorio de trabajo. Comprobaremos d enuevo el estado y desharemos los cambios realizados en el fichero para volver a la versi\u00f3n anterior del archivo. </li> </ol> <ol> <li>En este caso eliminaremos tambi\u00e9n el fichero, quitando los cambios en la zona de intercambio temporal pero mantenerlos en el directorio de trabajo. </li> </ol> <ol> <li>Haremos un commit, para luego ver como se puede deshacer manteniendo los cambios anteriores en el directorio de trabajo y la zona de intercambio temporal.  </li> </ol>"},{"location":"#comandos-utiles","title":"Comandos utiles.","text":"<ul> <li>git restore: deshacer cambios y volver a la versi\u00f3n anterior. </li> <li>git restore --staged: quitar los cambios de la zona temporal pero mantenerlos en el directorio de trabajo. </li> <li>git reset --soft HEAD~1: Deshacer el \u00faltimo commit pero mantener cambios en el staging. </li> <li>git reset --hard HEAD~1: Deshacer el \u00faltimo commit y eliminar cambios en el directorio de trabajo. </li> </ul>"},{"location":"#ejercicios-de-gestion-de-ramas","title":"Ejercicios de gesti\u00f3n de ramas.","text":"<ol> <li> <p>Creamos la rama bibliografia. </p> </li> <li> <p>Creamos archivo y modificamos,lo a\u00f1adimos y realizamos un commit con un mensaje, por \u00faltimo, mostraremos la historia del repositorio incluyendo todas las ramas. </p> </li> <li> <p>Cambiamos de rama a la rama bibliograf\u00eda. Creamos el fichero y a\u00f1adimos los cambios, haremos un commit y mostraremos la historia del repositorio incluyendo todas las ramas. </p> </li> </ol> <p></p> <ol> <li>Fusionamos la rama bibliograf\u00eda con la main, y luego la eliminaremos y mostramos la historia del repositorio incluyendo todas la ramas. </li> </ol> <p></p> <ol> <li>En este apartado trabajaremos los posibles conflictos que puede tener el merge con la rama main y no has hecho los cambios adecuados. </li> </ol> <p></p>"},{"location":"#comandos-utiles_1","title":"Comandos utiles.","text":"<ul> <li>git branch : Para listar las ramas.</li> <li>git branch  &lt;nombreRama&gt;; Para crear una rama.</li> <li>git checkout &lt;nombreRama&gt;; Para cambiar a esa rama. </li> <li>git merge &lt;nombreRama&gt;; Para fusionar rama con main. </li> <li>git branch -d &lt;nombreRama&gt;; Eliminar una rama. </li> </ul>"},{"location":"#ejercicios-de-repositorios-remotos","title":"Ejercicios de repositorios remotos.","text":"<ol> <li>Creamos un repositorio, lo a\u00f1adimos al repositorio local del libro y mostraos todos los repositorios remotos configurados. </li> <li>A\u00f1adimos los cambios al repositorio local de github y accedemos a github para su comprobaci\u00f3n. </li> </ol> <ol> <li>Colaboraremos en el repositorio remoto de un compa\u00f1ero, lo clonaremos y a\u00f1adiremos el fichero autores.txt que contenga el nombre del usuario y su correo electr\u00f3nico. lo a\u00f1adimos a la zona de intercambio temporal y haremos un commit con un mensaje. Subiremos los cambios al repositorio remoto. </li> <li>Bifurcaremos el repositorio en github, clonaremos el repositorio en la cuenta creada, crearemos una rama autoria y la activaremos. A\u00f1adiremos el nombre y email al archivo autores.txt, a\u00f1adimos los cambios a la zona temporal y haremo sun commit. Subiremos los cambios de la rama autoria y tras esto haremos un Pull request. </li> </ol>"},{"location":"#comandos-utiles_2","title":"Comandos utiles.","text":"<ul> <li>git remote add origin url; Para enlazar un repositorio de github con uno local.  -git remote -v : Mostrar todos los repositorios remotos configurados. </li> <li>git push -u origin &lt;rama&gt;: Subir los cambios a la rama. </li> <li>git clone url: clonar el repositorio a tu carpeta. </li> </ul>"}]}